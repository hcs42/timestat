#!/usr/bin/env python3

# This file is part of Timestat.
#
# Timestat is free software: you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
#
# Timestat is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with
# Timestat.  If not, see <http://www.gnu.org/licenses/>.

# Copyright (C) 2009-2014 Csaba Hoch


"""Program for creating time statistics about activities one does.

See README.markdown for more information."""


##### Imports #####


import datetime
import errno
import optparse
import os
import re
import subprocess
import sys


##### Helper functions: error handling #####

class Exit(Exception):

    def __init__(self, retcode, msg, data=None):
        self.retcode = retcode
        if data is not None:
            msg = msg % data
        self.msg = msg


##### Helper functions: printing text #####


def w(s, *data):
    if len(data) > 0:
        s = s % data
    sys.stdout.write(s)


def wl(s=None, *data):
    if len(data) > 0:
        s = s % data
    if s is not None:
        sys.stdout.write(s)
    sys.stdout.write('\n')
    sys.stdout.flush()


##### Helper functions: date and time #####


def timedelta_to_seconds(td):
    return int(td.total_seconds())


def seconds_to_timedelta(seconds):
    return datetime.timedelta(seconds=seconds)

def isoweek_to_date(year, week, day):
    dt = datetime.datetime.strptime('%04d-%02d-1' % (year, week), '%Y-%W-%w')
    if datetime.date(year, 1, 4).isoweekday() > 4:
        dt -= datetime.timedelta(days=(8 - day))
    return datetime.date(dt.year, dt.month, dt.day)

def str_to_date(s):

    if s in ('t', 'today'):
        return datetime.date.today()

    if s in ('y', 'yesterday'):
        return datetime.date.today() - datetime.timedelta(days=1)

    if all([ch == 'y' for ch in s]):
        return datetime.date.today() - datetime.timedelta(days=len(s))

    r = re.match('^(\d\d\d\d)-(\d\d)-(\d\d)$', s)
    if r:
        return datetime.date(
                   int(r.group(1)),
                   int(r.group(2)),
                   int(r.group(3)))

    r = re.match('^(\d\d\d\d)-[Ww](\d\d)-(\d)$', s)
    if r:
        return isoweek_to_date(
                   int(r.group(1)),
                   int(r.group(2)),
                   int(r.group(3)))

    r = re.match('^[Ww](\d\d\d\d)-(\d\d)-(\d)$', s)
    if r:
        return isoweek_to_date(
                   int(r.group(1)),
                   int(r.group(2)),
                   int(r.group(3)))

    year = datetime.date.today().year
    r = re.match('^(\d\d)-(\d\d)$', s)
    if r:
        return datetime.date(
                   year,
                   int(r.group(1)),
                   int(r.group(2)))

    r = re.match('^[Ww](\d\d)-(\d)$', s)
    if r:
        return isoweek_to_date(
                   year,
                   int(r.group(1)),
                   int(r.group(2)))

    raise Exit(1, 'Not a valid date: %s', s)


def date_to_str(d):
    return d.strftime('%Y-%m-%d')


def str_to_datetime(s):
    return datetime.datetime.strptime(s, '%Y-%m-%d %H:%M:%S')


def datetime_to_str(dt):
    return dt.strftime('%Y-%m-%d %H:%M:%S')


def hhmm_to_seconds(s):
    # Accepted formats:
    # - M
    # - H:M
    # - H:M:S

    r = re.match('^(\d+)$', s)
    if r:
        hours, minutes, seconds = 0, int(r.group(1)), 0

    r = re.match('^(\d+):(\d+)$', s)
    if r:
        hours, minutes, seconds = int(r.group(1)), int(r.group(2)), 0

    r = re.match('^(\d+):(\d+):(\d+)$', s)
    if r:
        hours, minutes, seconds = \
            int(r.group(1)), int(r.group(2)), int(r.group(3))

    return hours * 3600 + minutes * 60 + seconds


def seconds_to_hhmm(seconds, show_seconds=False, negative=False):
    if seconds < 0:
        return seconds_to_hhmm(-seconds, show_seconds, True)

    minutes = seconds / 60
    if show_seconds:
        hhmm = '%02d:%02d:%02d' % (minutes / 60, minutes % 60, seconds % 60)
    else:
        hhmm = '%02d:%02d' % (minutes / 60, minutes % 60)

    if negative:
        hhmm = '-' + hhmm

    return hhmm


def get_now():
    # Get rid of microseconds
    now = datetime.datetime.now()
    return datetime.datetime(year=now.year,
                             month=now.month,
                             day=now.day,
                             hour=now.hour,
                             minute=now.minute,
                             second=now.second)


##### Helper functions: misc #####


class ReMatch():

    def match(self, *args, **kw):
        self.r = re.match(*args, **kw)
        return self.r

    def __getattr__(self, attr):
        return getattr(self.r, attr)


def editor_to_editor_list(editor):
    r"""Converts an editor variable to a list of program name and arguments.

    Argument:

    - editor (str)

    Returns: [str]

    Examples:

        >>> editor_to_editor_list('gvim')
        ['gvim']
        >>> editor_to_editor_list('vim arg1 arg2')
        ['vim', 'arg1', 'arg2']
        >>> editor_to_editor_list('vim long\\ argument')
        ['vim', 'long argument']
        >>> editor_to_editor_list('vim argument\\\\with\\\\backslash')
        ['vim', 'argument\\with\\backslash']
    """

    editor_list = []
    current_arg = []
    i = 0
    while i < len(editor):
        # If a backslash is found, the next character has to be a space or a
        # backslash, and it should be added to the current argument.
        if editor[i] == '\\':
            if len(editor) <=  i + 1:
                raise Exit(1, 'Unescaped backslash in $EDITOR should not be '
                              'the final character.')
            i += 1
            if editor[i] in [' ', '\\']:
                current_arg.append(editor[i])
            else:
                raise Exit(1, 'Unexpected character after backslash in '
                              '$EDITOR.')
        # If a space is found, a new argument should be started.
        elif editor[i] == ' ':
            if current_arg != []:
                editor_list.append(''.join(current_arg))
                current_arg = []
        # Otherwise the current character has to be added to the current
        # argument.
        else:
            current_arg.append(editor[i])
        i += 1
    if current_arg != []:
        editor_list.append(''.join(current_arg))
        current_arg = []
    return editor_list


def call(cmd):
    try:
        return subprocess.call(cmd)
    except OSError as e:
        raise Exit(1, 'The operating system returned the following error:\n%s\n'
                      'When trying to execute the following command:\n%s',
                      (e, cmd))


##### Model classes: actions, events, happenings #####

# Data model:
#
# - action examples:
#     - start doing something
#     - stop doing anything
#     - reporting doing something for a time duration
#     - adding a target
# - happening examples:
#     - event: doing something in a time interval or for a time duration
#     - action: adding a target
#  - activity example:
#     - "hobby/book-reading"

class Happening:

    def is_action(self):
        return False

    def is_event(self):
        return False


class Action(Happening):

    # Fields:
    # - datetime
    # - text
    # - type: start | stop | interval | target
    # - activity
    # - timelen (seconds; only if type is 'interval' or 'target')
    # - source (source[0] = actionfile, source[1] = line number)

    fields = ('datetime', 'text', 'type', 'activity', 'timelen', 'source')

    def __init__(self, **kwargs):
        for field in Action.fields:
            setattr(self, field, kwargs.get(field))

    def __eq__(self, other):
        if other.__class__ != Action:
            return False
        for attr in Action.fields:
            if getattr(self, attr) != getattr(other, attr):
                return False
        return True

    def __ne__(self, other):
        return not self.__eq__(other)

    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        field_strs = [ '%s=%s' % (attr, getattr(self, attr))
                       for attr in Action.fields ]
        return '<Action: %s>' % (', '.join(field_strs))

    def is_action(self):
        return True

    def get_source(self):
        if self.source is None:
            return '<no_source>'
        else:
            return 'file %s line %s' % (self.source[0], self.source[1])

    def __lt__(self, other):

        if ((self.type == 'interval') and not (other.type == 'interval')):
            return True # intervals first
        elif (not (self.type == 'interval') and (other.type == 'interval')):
            return False # intervals first
        else:
            return self.datetime < other.datetime

    def __gt__(self, other):
        # This function is not implemented, so I added an "assert False" to
        # make sure it is not accidentaly used. When it would be useful, it can
        # be properly implemented and tested.
        assert False

    def __le__(self, other):
        # This function is not implemented, so I added an "assert False" to
        # make sure it is not accidentaly used. When it would be useful, it can
        # be properly implemented and tested.
        assert False

    def __ge__(self, other):
        # This function is not implemented, so I added an "assert False" to
        # make sure it is not accidentaly used. When it would be useful, it can
        # be properly implemented and tested.
        assert False

    def calc(self):
        """This function fills in self.type, self.accidentaly and self.timelen,
        based on self.text."""
        r = ReMatch()
        if self.text == '':
            return False
        if self.text == 'stop':
            self.type = 'stop'
        elif r.match('^([^ ]+)$', self.text):
            self.type = 'start'
            self.activity = r.group(1)
        elif r.match('^increase-target ([^ ]+) ((?:\d|:)+)$', self.text):
            self.type = 'target'
            self.activity = r.group(1)
            self.timelen = hhmm_to_seconds(r.group(2))
        elif r.match('^((?:\d|:)+) ([^ ]+)$', self.text):
            self.type = 'interval'
            self.timelen = hhmm_to_seconds(r.group(1))
            self.activity = r.group(2)
        else:
            wl('WARNING: Incorrect action in %s: %s',
               self.get_source(), self.text)
            return False
        return True

    def between(self, since, until):
        return ((since == None or self.datetime.date() >= since) and
                (until == None or self.datetime.date() <= until))


class Event(Happening):

    # Fields:
    # - starttime (datetime)
    # - stoptime (datetime)
    # - activity (string)
    # - timelen (integer: seconds)
    # - ongoing (bool)
    # - is_interval_action (bool): the event was created from an interval action

    fields = ('starttime', 'stoptime', 'activity', 'timelen', 'ongoing',
              'is_interval_action')

    def __init__(self, **kwargs):
        for field in Event.fields:
            setattr(self, field, kwargs.get(field))
        if self.ongoing is None:
            self.ongoing = False
        if self.is_interval_action is None:
            self.is_interval_action = False

    def __eq__(self, other):
        if other.__class__ != Event:
            return False
        for attr in Event.fields:
            if getattr(self, attr) != getattr(other, attr):
                return False
        return True

    def __ne__(self, other):
        return not self.__eq__(other)

    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        field_strs = [ '%s=%s' % (attr, getattr(self, attr))
                       for attr in Event.fields ]
        return '<Event: %s>' % (', '.join(field_strs))

    def is_event(self):
        return True

    def between(self, since, until):
        """Returns whether the start time of this event is between `since` and
        `until`."""
        # Maybe we should return the event only if the whole event is inside
        # the given range, i.e. if
        #     since <= starttime <= stoptime <= until
        # is true?
        #
        # Or maybe we should return it if there is an overlap between the
        # since-until range and the event, i.e. if
        #     (since <= starttime <= until) or
        #     (since <= stoptime <= until)
        # holds?
        return ((since == None or self.starttime.date() >= since) and
                (until == None or self.starttime.date() <= until))


##### Action file handling #####

def split_comment(text):
    r = re.match(r'^(.*?)(?:|\s+#\s*(.*))$', text)
    text = r.group(1).strip()
    comment = r.group(2) if r.group(2) is not None else ''
    return text, comment

def process_actionfile_line(dt, text, actions, source):
    text, comment = split_comment(text)
    action = Action(datetime = dt,
                    text = text,
                    source = source)
    add = action.calc()
    if add:
        actions.append(action)


def parse_actionfile(filename):
    actions = []
    with open(filename) as f:
        for lnum, line in enumerate(f):
            source = (filename, lnum)
            line = line.strip()
            if line != '' and line[0] != '#':
                try:
                    r = re.match(
                            r'\[(?P<year>\d\d\d\d)-'
                            r'(?P<month>\d\d)-'
                            r'(?P<day>\d\d) '
                            r'(?P<hour>\d\d):'
                            r'(?P<minute>\d\d):'
                            r'(?P<second>\d\d)\]\s+'
                            r'(?P<text>.*)',
                            line)
                    assert(r != None)
                    dt = datetime.datetime(
                             int(r.group('year')),
                             int(r.group('month')),
                             int(r.group('day')),
                             int(r.group('hour')),
                             int(r.group('minute')),
                             int(r.group('second')))
                    process_actionfile_line(dt, r.group('text'), actions,
                                            source)
                except Exception as e:
                    wl('WARNING: Incorrect line in file %s line %s: %s',
                       filename, lnum, line)
    return actions


def collect_actions(options):
    actions = []
    for actionfile in options.actionfiles:
        actions += parse_actionfile(actionfile)
    actions.sort()
    return actions

def is_activity_needed(act, opt):
    ignore_act = opt.ignore_activities
    ignore_act_pattern = opt.ignore_activities_pattern
    only_act = opt.only_activities
    only_act_pattern = opt.only_activities_pattern

    if ignore_act and (act in ignore_act):
        return False
    elif ignore_act_pattern and re.search(ignore_act_pattern, act):
        return False
    elif not (only_act or only_act_pattern):
        return True
    elif only_act and (act in only_act):
        return True
    elif only_act_pattern and re.search(only_act_pattern, act):
        return True
    else: # only_act or only_act_pattern is set, but the act. does not match
        return False

def collect_happenings(options, actions, now=None):

    if now is None:
        now = get_now()

    happenings = []

    def add_event(activity, starttime, timelen, is_interval_action):
        """Adds an activity to the dict."""
        if is_activity_needed(activity, options):
            event = Event(activity=activity,
                          starttime=starttime,
                          timelen=timelen,
                          is_interval_action=is_interval_action)
            if timelen is not None:
                event.stoptime = event.starttime + \
                    seconds_to_timedelta(timelen)
            else:
                event.ongoing = True
            happenings.append(event)

    def close_prev_event(stoptime, ongoing):

        # Find the last event
        i = len(happenings) - 1
        while i >= 0:
            if (happenings[i].is_event() and
                not happenings[i].is_interval_action):
                last_event = happenings[i]
                break
            i -= 1
        else:
            # No event found
            return

        # Close the last event
        if last_event.ongoing:
            last_event.stoptime = stoptime
            last_event.timelen = \
                timedelta_to_seconds(stoptime - last_event.starttime)
            if not ongoing:
                last_event.ongoing = False

    for action in actions:
        if action.type == 'interval':
            add_event(action.activity, action.datetime, action.timelen, True)
        elif action.type == 'start':
            close_prev_event(action.datetime, ongoing=False)
            add_event(action.activity, action.datetime, None, False)
        elif action.type == 'stop':
            close_prev_event(action.datetime, ongoing=False)
        elif action.type == 'target':
            happenings.append(action)

    close_prev_event(now, ongoing=True)

    happenings = [ happening for happening in happenings
                   if happening.between(options.since, options.until) and
                      eval(options.only_expr, {}, {'h': happening})]

    return happenings


def collect_events(options, happenings):
    return [ happening for happening in happenings
                       if happening.is_event() ]


# Result: {activity (str): seconds (int)}
def collect_activities(options, events):
    activities = {}
    for event in events:
        activities.setdefault(event.activity, 0)
        activities[event.activity] += event.timelen
    return activities


# Result: {activity (str): seconds (int)}
def collect_activities_hotness(options, events):
    activities = []
    for event in reversed(events):
        if event.activity not in activities:
            activities.append(event.activity)
    return activities


def get_categories(activity):
    words = activity.split('/')
    return [ '/'.join(words[:i]) for i in range(1, len(words) + 1) ]


def collect_targets(options, happenings, activities):
    targets = {}

    # Collect targets
    for happening in happenings:
        if happening.is_action() and happening.type == 'target':
            targets.setdefault(
                happening.activity,
                {'target_timelen': 0,
                 'actual_timelen': 0})
            targets[happening.activity]['target_timelen'] += happening.timelen

    # Collect work
    for activity, seconds in activities.items():
        for category in get_categories(activity):
            if category in targets:
                targets[category]['actual_timelen'] += seconds
    return targets


def collect_everything(options):
    actions = collect_actions(options)
    happenings = collect_happenings(options, actions)
    events = collect_events(options, happenings)
    activities = collect_activities(options, events)
    return actions, happenings, events, activities

##### Command functions #####


def show_sum(options, datetime_to_key, key_to_date, key_to_text, step_days):

    # Fill in the dictionary of sums
    actions, happenings, events, activities = collect_everything(options)
    d = {}
    for event in events:
        key = datetime_to_key(event.starttime)
        d.setdefault(key, 0)
        d[key] += event.timelen

    # Fill the missing weeks
    if options.fill:
        if options.since is not None:
            start_day = options.since
        else:
            if len(d) > 0:
                start_day = key_to_date(min(d.keys()))
            else:
                start_day = None
        if start_day is not None:
            step = datetime.timedelta(days=step_days)
            day = start_day
            while day <= options.until:
                key = datetime_to_key(day)
                if not key in d:
                    d[key] = 0
                day += step

    # Print the sums
    block = options.block_seconds
    for k in sorted(d.keys()):
        w(key_to_text(k))               # date (range)
        if options.show_time:
            # time with hh:mm format
            w(' (%s)', seconds_to_hhmm(d[k], options.seconds))
        w(' ' if d[k] >= block else '')  # space
        w('x' * (d[k] // block))         # number of hours
        wl()
    if options.avg:
        avg_time = seconds_to_hhmm(sum(d.values()) / len(d), options.seconds)
        wl('Average: %s', avg_time)

def show_daily_sum(options):
    # key = (year, month, day)
    def datetime_to_key(dt):
        return (dt.year, dt.month, dt.day)
    def key_to_date(key):
        return datetime.date(*key)
    def key_to_text(key):
        return '%04d-%02d-%02d' % key
    return show_sum(options, datetime_to_key, key_to_date, key_to_text, 1)


def show_weekly_sum(options):
    # key = (year, week_number)
    def datetime_to_key(dt):
        year, week_number, week_day = dt.isocalendar()
        return (year, week_number)
    def key_to_date(key):
        year, week_number = key
        return isoweek_to_date(year, week_number, 1)
    def key_to_text(key):
        return '%s-w%02d' % key
    return show_sum(options, datetime_to_key, key_to_date, key_to_text, 7)


def show_monthly_sum(options):
    # key = (year, month)
    def datetime_to_key(dt):
        return (dt.year, dt.month)
    def key_to_date(key):
        return datetime.date(key[0], key[1], 1)
    def key_to_text(key):
        return '%04d-%02d' % key
    # Step = 28 is fine. If a month is longer, maybe we will examine one month
    # twice.
    return show_sum(options, datetime_to_key, key_to_date, key_to_text, 28)


def show_status(options):
    actions, happenings, events, activities = collect_everything(options)

    if len(events) == 0:
        wl('No event found.')

    else:
        event = events[-1]
        wl('State: %s', 'on' if event.ongoing else 'off')
        wl('%s activity: %s',
           'Current' if event.ongoing else 'Last',
           event.activity)
        wl('Start time: %s', event.starttime.strftime('%H:%M'))

        if event.ongoing:
            wl('Current time: %s', event.stoptime.strftime('%H:%M'))
            wl('Time since started: %s',
                   seconds_to_hhmm(event.timelen, options.seconds))
        else:
            wl('Stop time: %s', event.stoptime.strftime('%H:%M'))
            wl('Time length: %s',
               seconds_to_hhmm(event.timelen, options.seconds))


def show_targets(options):
    actions, happenings, events, activities = collect_everything(options)
    targets = collect_targets(options, happenings, activities)
    for target_name, target_result in sorted(targets.items()):
        target_timelen = target_result['target_timelen']
        actual_timelen = target_result['actual_timelen']
        def show(timelen):
            return seconds_to_hhmm(timelen, options.seconds)
        wl('Target name: %s', target_name)
        wl('Target time: %s', show(target_timelen))
        wl('Actual time: %s', show(actual_timelen))
        wl('Difference: %s',  show(actual_timelen - target_timelen))
        wl('')

def print_object(name, options):
    actions, happenings, events, activities = collect_everything(options)

    if name == 'activities':
        for item in sorted(activities.items()):
            print(item)
    else:
        l = (actions if name == 'actions' else
             happenings if name == 'happenings' else
             events if name == 'events' else
             ['Object unknown: %s' % name])
        for item in l:
            print(item)

def show(options):
    if options.weekly_sum:
        show_weekly_sum(options)
    else:

        actions, happenings, events, activities = collect_everything(options)

        if options.current:
            if len(events) > 0 and events[-1].ongoing:
                event = events[-1]
                print('%s: %s' % (event.activity,
                                 seconds_to_hhmm(event.timelen,
                                                 options.seconds)))

        else:
            if not options.sum:
                d2 = {}
                for key, value in activities.items():
                    d2[key] = seconds_to_hhmm(value, options.seconds)
                for key, value in sorted(d2.items()):
                    print('%s: %s' % (key, value))

            time_sum = sum(activities.values())
            time_sum = seconds_to_hhmm(time_sum, options.seconds)
            if not options.nosum:
                wl('Sum: %s', time_sum)


def add_activity(options, activity, everything=None):

    if everything is None:
        everything = collect_everything(options)
    actions, happenings, events, activities = everything

    if activity == 'stop':
        if len(events) > 0 and events[-1].ongoing:
            wl('"%s" activity stopped', events[-1].activity)
            add(options, activity)
        else:
            wl('Do nothing: there is nothing to stop.')
    elif len(events) == 0:
        add(options, activity)
        wl('"%s" activity started', activity)
    elif events[-1].ongoing:
        if events[-1].activity == activity:
            wl('Do nothing: "%s" activity is going on anyway.',
               activity)
        else:
            add(options, activity)
            wl('"%s" activity started, "%s" activity stopped',
               activity, events[-1].activity)
    else:
        if events[-1].activity == activity:
            add(options, activity)
            wl('"%s" activity resumed', activity)
        else:
            add(options, activity)
            wl('"%s" activity started', activity)


def parse_add_cmd_args(args):

    assert(0 <= len(args) <= 2)
    if len(args) == 0:
        duration, activity = None, None
    elif len(args) == 1:
        duration, activity = None, args[0]
    elif len(args) == 2:
        duration, activity = args
    return activity, duration


def add(options, action):
    if options.actionfile == 'ALL':
        raise Exit(1, 'Action file "ALL" is not accepted by "add".')

    dt = get_now()
    actionfile_name = options.actionfile
    with open(actionfile_name, 'a') as f:
        text = '[%s] %s' % (datetime_to_str(dt), action)
        f.write(text)
        f.write('\n')
        if options.verbose:
            wl('%s extended with: %s', actionfile_name, text)


def edit(options):
    if options.actionfile == 'ALL':
        actionfile_names = options.actionfiles
    else:
        actionfile_names = [options.actionfile]
    editor = os.getenv('EDITOR', '')
    if editor == '':
        raise Exit(1, 'You should set the $EDITOR environment variable '
                      'to your favorite text editor.')
    editor_list = editor_to_editor_list(editor)
    call(editor_list + actionfile_names)


def list_actionfiles(options):
    for actionfile in options.actionfiles:
        wl(actionfile)


def expand_activity(activity, activities):

    if len(activity) == 0:
        raise Exit(1, 'Empty activity specified.')

    if activity[0] == '%':
        activity = activity[1:]
        act_hits = [act for act in activities
                    if re.search(activity, act)][:20]
        if len(act_hits) == 0:
            raise Exit(1, 'No activity matches "%s"', activity)
        elif len(act_hits) == 1:
            activity = act_hits[0]
        else:
            wl('Select the desired match (empty line = cancel):')

            for i, act in enumerate(act_hits):
                wl('%s: %s', i + 1, act)
            while True:
                sys.stdout.write('> ')
                sys.stdout.flush()
                line = sys.stdin.readline().strip()
                if line == '':
                    raise Exit(0, 'Cancelled.')
                else:
                    try:
                        act_index = int(line)
                        assert(act_index > 0)
                        activity = act_hits[act_index - 1]
                        # Matching activity set; quit this branch and let the
                        # rest of quickadd() to handle it.
                        break
                    except Exception:
                        wl('Please type one of the numbers above or an '
                           'empty line to cancel.')
    return activity


def quickadd(options, activity, duration=None):

    actions, happenings, events, activities = collect_everything(options)
    if activity is not None:
        activities_hot = collect_activities_hotness(options, events)
        activity = expand_activity(activity, activities_hot)

    # If we have a duration, just pass it to "add"
    if duration is not None:
        add(options, duration + ' ' + activity)
        return

    # If we have an activity, just pass it to "add_activity"
    if activity is not None:
        add_activity(options, activity)
        return

    # If we don't have a parameter...

    # If there are no events, we don't know what to do
    if len(events) == 0:
        raise Exit(1, 'Action file does not contain any event.')

    # If the last event is not ongoing, let's resume it
    elif not events[-1].ongoing:
        add(options, events[-1].activity)
        wl('"%s" activity resumed', events[-1].activity)

    # If the last event is ongoing, let's examine what we were doing at the
    # moment when this last event was started!
    #
    # If we had already been doing something, let's resume that activity.
    elif (len(events) > 1) and (events[-2].stoptime == events[-1].starttime):
        add(options, events[-2].activity)
        wl('"%s" activity resumed, "%s" activity stopped',
           events[-2].activity, events[-1].activity)

    # Otherwise let's stop (i.e. resume the 'stopped' state that we had before
    # the current activity.).
    else:
        add(options, 'stop')
        wl('"%s" activity stopped', events[-1].activity)


def print_full_help():
    f = sys.argv[0]
    f = os.readlink(f) if os.path.islink(f) else f
    with open(os.path.join(os.path.dirname(f), 'README.markdown')) as readme:
        sys.stdout.write(readme.read())


##### Option and command parsing #####


def parse_args(input_args):

    parser = optparse.OptionParser(
                usage='''%prog [options] [COMMAND [COMMAND PARAMETERS]]

Read README.markdown more information. You can print it by typing
"timestat full-help".

Commands:
  full-help             Print the full documentation.
  add ACTION            Add an action to the action file.
  quickadd ACTION       Perform the "next logical step".
  edit                  Open the action file in a text editor.
  list                  List all action files.
  print actions         Print all actions.
  print activities      Print all activities.
  print events          Print all events.
  show                  Show stats about the activities.
  show-sum              Show daily/weekly/monthly summary about time spent.
  show-status           Show the current activity.
  show-targets          Show targets.
  test                  Run unit tests''', version = '%prog 3.0')

    # Common options
    parser.add_option('-f', '--actionfiles', dest='actionfiles',
                      help='Action files, separated with colon')
    parser.add_option('-v', '--verbose', dest='verbose',
                      action='store_true', default=False,
                      help='Verbose printout')

    # "show" options
    parser.add_option('--from', dest='FROM',
                      help='Work with actions since this date.')
    parser.add_option('--to', dest='TO', default='today',
                      help='Work with actions until this date.')
    parser.add_option('-d', '--day', dest='day',
                      help='Work with actions on this date.')
    parser.add_option('--week', dest='week',
                      help='Work with actions on this week.')
    parser.add_option('-t', '--today', dest='today',
                      action='store_true', default=False,
                      help='Same as --day today.')
    parser.add_option('-y', '--yesterday', dest='yesterday',
                      action='store_true', default=False,
                      help='Same as --day yesterday.')
    parser.add_option('-w', '--weekly-sum', dest='weekly_sum',
                      action='store_true', default=False,
                      help='Print a weekly summary.')
    parser.add_option('--fill', dest='fill',
                      action='store_true', default=False,
                      help='When printing a summary, print all dates (not '
                           'only those with time spent).')
    parser.add_option('--show-time', dest='show_time',
                      action='store_true', default=False,
                      help='When printing a summary, print time too.')
    parser.add_option('--avg', dest='avg',
                      action='store_true', default=False,
                      help='When printing a summary, print the average.')
    parser.add_option('--block-seconds', dest='block_seconds', type='int',
                      default=3600,
                      help='When printing a summary, one "x" will represent '
                           'BLOCK_SECONDS seconds.')
    parser.add_option('-s', '--sum', dest='sum',
                      action='store_true', default=False,
                      help='Print only the sum of the activity time.')
    parser.add_option('--nosum', dest='nosum',
                      action='store_true', default=False,
                      help='Do not print the sum of the activity time.')
    parser.add_option('-i', '--ignore-activities', dest='ignore_activities',
                      default=None,
                      help='Ignores the given activities.')
    parser.add_option('-I', '--ignore-activities-pattern',
                      dest='ignore_activities_pattern',
                      default=None,
                      help='Ignores the activities that match the given '
                           'pattern.')
    parser.add_option('-o', '--only-activities', dest='only_activities',
                      default=None,
                      help='Considers only the given activities.')
    parser.add_option('-O', '--only-activities-pattern',
                      dest='only_activities_pattern',
                      default=None,
                      help='Considers only the activities that match the '
                           'given pattern.')
    parser.add_option('--only-expr', dest='only_expr',
                      default='True',
                      help='Considers only happenings for which ONLY_EXPR is '
                           'true.')
    parser.add_option('-c', '--current', dest='current',
                      action='store_true', default=False,
                      help='Display the name of ongoing task, if any.')
    parser.add_option('--seconds', dest='seconds',
                      action='store_true', default=False,
                      help='Show seconds')

    # "add" and "edit" options
    parser.add_option('-a', '--actionfile', dest='actionfile',
                      help='Specify which action file to use.')

    options, args = parser.parse_args(input_args)

    if len(args) > 0 and args[0] == 'test':
        return options, args

    # "from" is a keyword in Python, so let's use the words "since" and "until"
    # instead of "from" and "to".
    options.since = options.FROM
    options.until = options.TO

    # Prepare: since and until
    if options.since is not None:
        options.since = str_to_date(options.since)

    options.until = str_to_date(options.until)

    if options.since is not None and options.since > options.until:
        raise Exit(1, '"From" date (%s) is after "to" date (%s).',
                   (date_to_str(options.since),
                    date_to_str(options.until)))

    if options.today:
        options.day = 'today'

    if options.yesterday:
        options.day = 'yesterday'

    if options.week is not None:
        options.since = str_to_date('w' + options.week + '-1')
        options.until = str_to_date('w' + options.week + '-7')

    if options.day is not None:
        options.since = str_to_date(options.day)
        options.until = str_to_date(options.day)

    # Prepare: ignore_activities, only_activities
    if options.ignore_activities is not None:
        options.ignore_activities = \
            set(options.ignore_activities.split(':')) - set([''])

    if options.only_activities is not None:
        options.only_activities = \
            set(options.only_activities.split(':')) - set([''])

    # Prepare: actionfiles
    if options.actionfiles is not None:
        options.actionfiles = options.actionfiles.split(':')
    elif os.getenv('ACTIONFILES') not in (None, ''):
        options.actionfiles = os.getenv('ACTIONFILES').split(':')
    else:
        # If there is no action file, don't proceed.
        return options, args

    # Prepare: actionfile
    if options.actionfile is None:
        options.actionfile = options.actionfiles[0]
    elif options.actionfile == 'ALL':
        pass
    else:
        match_count = 0
        for actionfile_iter in options.actionfiles:
            if options.actionfile in os.path.basename(actionfile_iter):
                actionfile = actionfile_iter
                match_count += 1
        if match_count == 1:
            options.actionfile = actionfile
        else:
            if match_count == 0:
                msg = 'Cannot find action file in action file list.\n'
            else:
                msg = 'More than one action files match.\n'
            msg += 'Action file: ' + str(options.actionfile) + '\n'
            msg += 'Action file list: ' + str(options.actionfiles)
            raise Exit(1, msg)

    return options, args


##### Main function (running the commands) #####


def check_args(args, a, b=None):
    if b is None:
        b = a

    if a <= len(args) - 1 <= b:
        return
    else:
        def plural(s, n):
            return s % (n, 's' if n >= 2 else '')

        msg = ('The "%s" command requires ' % args[0])
        if a == b == 0:
            msg += 'no argument.'
        elif a == b:
            msg += plural('exactly %s argument%s.', a)
        elif len(args) - 1 < a:
            msg += plural('at least %s argument%s.', a)
        elif b < len(args) - 1:
            msg += plural('at most %s argument%s.', b)
        raise Exit(1, msg)


def main_core(input_args):

    options, args = parse_args(input_args)

    # Commands that don't need action files
    if args == []:
        pass
    elif args[0] == 'full-help':
        check_args(args, 0)
        print_full_help()
        return
    elif args[0] in ('t', 'test'):
        check_args(args, 0, 1)
        if len(args) == 1:
            run_unittest()
        else:
            run_unittest(args[1])
        return
    elif args[0] in ('tc', 'test-coverage'):
        check_args(args, 0)
        run_coverage()
        return

    # Check action files
    if options.actionfiles is None:
        raise Exit(1, 'You should set either the ACTIONFILES environment '
                      'variable or give --actionfiles argument!')

    # Commands that do need action files
    if args == []:
        show(options)
    elif args[0] == 'show':
        check_args(args, 0)
        show(options)
    elif args[0] == 'show-sum':
        check_args(args, 1)
        if args[1] == 'daily':
            show_daily_sum(options)
        elif args[1] == 'weekly':
            show_weekly_sum(options)
        elif args[1] == 'monthly':
            show_monthly_sum(options)
    elif args[0] in ('ss', 'show-status'):
        check_args(args, 0)
        show_status(options)
    elif args[0] in('st', 'show-targets'):
        check_args(args, 0)
        show_targets(options)
    elif args[0] in ('print'):
        check_args(args, 1)
        print_object(args[1], options)
    elif args[0] in ('a', 'add'):
        check_args(args, 1, 2)
        add(options, ' '.join(args[1:]))
    elif args[0] == 'quickadd':
        check_args(args, 0, 2)
        activity, duration = parse_add_cmd_args(args[1:])
        quickadd(options, activity, duration)
    elif args[0] in ('e', 'edit'):
        check_args(args, 0)
        edit(options)
    elif args[0] == 'list':
        check_args(args, 0)
        list_actionfiles(options)
    else:
        raise Exit(1, 'Unrecognized command: %s.', args[0])


def run_unittest(test_case=None):
    """Runs the given test case. If no test case is specified, all tests are
    executed.

    After running the tests, it exits with 0 if all tests passed, and exits
    with 1 otherwise."""

    if test_case == None:
        sys.argv = sys.argv[0:1] # unittest reads sys.argv
        unittest.main(verbosity=0)
    else:
        suite = unittest.TestSuite()
        suite.addTest(TestTimestat(test_case))
        res = unittest.TextTestRunner().run(suite)
        sys.exit(0 if res.wasSuccessful() else 1)


def run_coverage():
    try:
        call(['coverage', 'run', sys.argv[0], 'test'])
        call(['coverage', 'report'])
        call(['coverage', 'html'])
        wl('Coverage report ready (open htmlcov/index.html).')
    except Exit as e:
        e.msg += '''
Probably this means that "coverage" is not installed. You can install coverage
with "pip install coverage" (you may also need "sudo").'''
        raise e


def main():
    try:
        main_core(sys.argv[1:])
    except Exit as e:
        if e.retcode == 0:
            wl(e.msg)
        else:
            wl('Error: %s', e.msg)
            sys.exit(1)


##### Unit tests #####


import unittest
import tempfile


class TestTimestat(unittest.TestCase):

    ##### setUp and tearDown #####

    def setUp(self):

        # Set up tempfile variable (used also in tearDown)
        self.tmpfile = ''

        # Empty environment variables
        os.environ['EDITOR'] = ''
        os.environ['ACTIONFILES'] = 'mock_actionfile_name'

        # Mock stdout
        self.output = ''
        class StdoutMock():
            def write(_self, s):
                self.output += s

            def flush(_self):
                pass

        self.real_stdout = sys.stdout
        self.real_stderr = sys.stderr
        sys.stdout = StdoutMock()
        sys.stderr = StdoutMock()

        # Mock datetime.date.today and datetime.datetime.now.
        # (Source: http://stackoverflow.com/a/4482067/17916)

        self.now = [2000, 1, 1, 0, 0, 0]

        class NewDate(datetime.date):
            @classmethod
            def today(cls):
                return cls(*self.now[0:3])
        datetime.date = NewDate

        class NewDatetime(datetime.datetime):
            @classmethod
            def now(cls):
                return cls(*self.now)
        datetime.datetime = NewDatetime

        # Mock call
        self.calls = []
        global call
        self.original_call = call
        def call(cmd):
            self.calls.append(cmd)

        # Fill in the options
        class Options:
            pass
        self.options = Options()
        self.options.actionfiles = None
        self.options.verbose = False
        self.options.since = None
        self.options.until = None
        self.options.today = False
        self.options.yesterday = False
        self.options.weekly_sum = False
        self.options.sum = False
        self.options.nosum = False
        self.options.ignore_activities = None
        self.options.ignore_activities_pattern = None
        self.options.only_activities = None
        self.options.only_activities_pattern = None
        self.options.only_expr = 'True'
        self.options.current = False
        self.options.seconds = False
        self.options.actionfile = None

        # Set unittest settings
        self.maxDiff = 2000

    def tearDown(self, only_assertions=False):
        global call

        if not only_assertions:
            sys.stdout = self.real_stdout
            sys.stderr = self.real_stderr
            call = self.original_call
            self.clean_tmpfile()

        if self.calls != []:
            raise AssertionError(
                      'self.calls contained the following commands after test '
                      'case execution:',
                      self.calls)

        if self.output != '':
            raise AssertionError(
                      'self.output contained the following line after test '
                      'case execution:\n' +
                      self.output.strip())

    def test_tearDown(self):
        try:
            self.calls = ['something']
            self.output = ''
            with self.assertRaises(AssertionError):
                self.tearDown(only_assertions=True)

            self.calls = []
            self.output = 'something'
            with self.assertRaises(AssertionError):
                self.tearDown(only_assertions=True)

        finally:
            self.calls = []
            self.output = ''

    def clean_tmpfile(self):
        if self.tmpfile != '':
            os.remove(self.tmpfile)
        self.tmpfile = ''

    ##### Helper functions #####

    def assertExit(self, context_manager, expected_retcode, expected_msg):
        """Assert that an Exit exception with a given return code and message
        was raised."""
        self.assertOutput('')
        e = context_manager.exception
        self.assertEqual(e.retcode, expected_retcode)
        self.assertEqual(e.msg, expected_msg)

    def assertOutput(self, *expected):
        """Assert that the given output was printed."""
        try:
            self.assertEqual(
                self.output.strip() + '\n',
                '\n'.join(expected).strip() + '\n')
        finally:
            # If the assertion fails, let's still make the output empty,
            # otherwise tearDown will complain, which is unnecessary, since
            # assertOutput compains anyway.
            self.output = ''

    def assertCalls(self, expected_calls):
        """Assert that the given call was made."""
        try:
            self.assertEqual(self.calls, expected_calls)
        finally:
            # If the assertion fails, let's still make the excepted calls
            # empty, otherwise tearDown will complain, which is unnecessary,
            # since assertCalls compains anyway.
            self.calls = []

    def create_action_file(self, content):

        self.clean_tmpfile()
        fd, filename = tempfile.mkstemp()
        self.tmpfile = filename
        os.write(fd, bytes(content, 'UTF-8'))
        os.close(fd)
        self.options.actionfile = filename
        self.options.actionfiles = [filename]
        os.environ['ACTIONFILES'] = filename
        return filename

    def read_action_file(self):
        with open(self.tmpfile) as f:
            return f.read()

    ##### Test pure functions #####

    def test_w(self):

        w('c')
        self.assertOutput('c')
        w('%s', 'd')
        self.assertOutput('d')
        w('%s', '%d')
        self.assertOutput('%d')
        w('%s: %s', 'a', 'b')
        self.assertOutput('a: b')

        wl('c')
        self.assertOutput('c')
        wl('%s', 'd')
        self.assertOutput('d')
        wl('%s', '%d')
        self.assertOutput('%d')
        wl('%s: %s', 'a', 'b')
        self.assertOutput('a: b')

    def test_timedelta_to_seconds(self):
        td = datetime.timedelta(seconds=148)
        self.assertEqual(timedelta_to_seconds(td), 148)

    def test_seconds_to_timedelta(self):
        self.assertEqual(seconds_to_timedelta(148),
                         datetime.timedelta(seconds=148))

    def test_str_to_date(self):

        d = datetime.date
        self.assertEqual(str_to_date('t'), d(2000, 1, 1))
        self.assertEqual(str_to_date('y'), d(1999, 12, 31))
        self.assertEqual(str_to_date('yy'), d(1999, 12, 30))
        self.assertEqual(str_to_date('yyy'), d(1999, 12, 29))
        self.assertEqual(str_to_date('yyyy'), d(1999, 12, 28))
        self.assertEqual(str_to_date('1941-03-26'), d(1941, 3, 26))
        self.assertEqual(str_to_date('03-26'), d(2000, 3, 26))

        self.assertEqual(str_to_date('2016-w01-1'), d(2016, 1, 4))
        self.assertEqual(str_to_date('2015-w01-1'), d(2014, 12, 29))
        self.assertEqual(str_to_date('2014-w01-1'), d(2013, 12, 30))
        self.assertEqual(str_to_date('2013-w01-1'), d(2012, 12, 31))
        self.assertEqual(str_to_date('2012-w01-1'), d(2012, 1, 2))
        self.assertEqual(str_to_date('2011-w01-1'), d(2011, 1, 3))
        self.assertEqual(str_to_date('2010-w01-1'), d(2010, 1, 4))
        self.assertEqual(str_to_date('2009-w01-1'), d(2008, 12, 29))
        self.assertEqual(str_to_date('2008-w01-1'), d(2007, 12, 31))

        self.assertEqual(str_to_date('2014-w01-6'), d(2014, 1, 4))
        self.assertEqual(str_to_date('2014-w01-7'), d(2014, 1, 5))

        self.assertEqual(str_to_date('w2014-01-7'), d(2014, 1, 5))

        self.assertEqual(str_to_date('w01-1'), d(2000, 1, 3))

        with self.assertRaises(Exit) as cm:
            str_to_date('03'),
        self.assertExit(cm, 1, 'Not a valid date: 03')

    def test_str_to_datetime(self):
        self.assertEqual(str_to_datetime('1952-03-11 04:42:42'),
                         datetime.datetime(1952, 3, 11, 4, 42, 42))

    def test_datetime_to_str(self):
        day = datetime.datetime(1952, 3, 11, 4, 42, 42)
        self.assertEqual(datetime_to_str(day), '1952-03-11 04:42:42')

    def test_date_to_str(self):
        day = datetime.datetime(1952, 3, 11)
        self.assertEqual(date_to_str(day), '1952-03-11')

    def test_get_now(self):
        self.assertEqual(get_now(), datetime.datetime(2000, 1, 1, 0, 0, 0))

    def test_hhmm_to_seconds(self):

        self.assertEqual(hhmm_to_seconds('0'), 0)
        self.assertEqual(hhmm_to_seconds('1'), 60)
        self.assertEqual(hhmm_to_seconds('100'), 60 * 100)

        self.assertEqual(hhmm_to_seconds('00:00'), 0)
        self.assertEqual(hhmm_to_seconds('1:40'), 60 * 100)
        self.assertEqual(hhmm_to_seconds('120:10'), 60 * 7210)

        self.assertEqual(hhmm_to_seconds('00:00:00'), 0)
        self.assertEqual(hhmm_to_seconds('1:40:00'), 60 * 100)
        self.assertEqual(hhmm_to_seconds('120:10:00'), 60 * 7210)

    def test_seconds_to_hhmm(self):

        self.assertEqual(seconds_to_hhmm(60 * 0), '00:00')
        self.assertEqual(seconds_to_hhmm(60 * 1), '00:01')
        self.assertEqual(seconds_to_hhmm(60 * 100), '01:40')
        self.assertEqual(seconds_to_hhmm(60 * 7210), '120:10')

        self.assertEqual(seconds_to_hhmm(- 60 * 1), '-00:01')
        self.assertEqual(seconds_to_hhmm(- 60 * 100), '-01:40')
        self.assertEqual(seconds_to_hhmm(- 60 * 7210), '-120:10')

        # Test show_seconds == True

        def f(*args):
            return seconds_to_hhmm(*args, show_seconds=True)

        self.assertEqual(f(60 * 0), '00:00:00')
        self.assertEqual(f(60 * 1), '00:01:00')
        self.assertEqual(f(60 * 100), '01:40:00')
        self.assertEqual(f(60 * 7210), '120:10:00')

        self.assertEqual(f(- 60 * 1), '-00:01:00')
        self.assertEqual(f(- 60 * 100), '-01:40:00')
        self.assertEqual(f(- 60 * 7210), '-120:10:00')

    def test_editor_to_editor_list(self):
        e = editor_to_editor_list
        self.assertEqual(e('gvim'), ['gvim'])
        self.assertEqual(e('vim arg1 arg2'), ['vim', 'arg1', 'arg2'])
        self.assertEqual(e('vim long\\ argument'), ['vim', 'long argument'])
        self.assertEqual(e('vim argument\\\\with\\\\backslash'),
                         ['vim', 'argument\\with\\backslash'])
        self.assertEqual(e('/home/My\\ Name/My\\ Editor long\\ argument'),
                         ['/home/My Name/My Editor', 'long argument'])

        with self.assertRaises(Exit) as cm:
            e('vim\\')
        self.assertExit(cm, 1, 'Unescaped backslash in $EDITOR should not be '
                               'the final character.')

        with self.assertRaises(Exit) as cm:
            e('vim\\x')
        self.assertExit(cm, 1, 'Unexpected character after backslash in '
                               '$EDITOR.')

    def test_call(self):

        original_subprocess_call = subprocess.call
        try:
            def my_call(cmd):
                wl('Call: %s', cmd)
            subprocess.call = my_call
            self.original_call(['ls', '/home'])
            self.assertOutput("Call: ['ls', '/home']")

            def my_call(cmd):
                raise OSError(errno.ENOENT, 'No such file', 'ls')
            subprocess.call = my_call
            with self.assertRaises(Exit) as cm:
                self.original_call(['ls', '/home'])
            self.assertExit(
                cm, 1,
                "The operating system returned the following error:\n"
                "[Errno 2] No such file: 'ls'\n"
                "When trying to execute the following command:\n"
                "['ls', '/home']")

        finally:
            subprocess.call = original_subprocess_call

    ##### Model classes: actions, events, happenings #####

    def test_Action(self):

        # Test Action.__init__
        a1 = Action(text=1, type=2, something=3)
        self.assertEqual(a1.text, 1)
        self.assertEqual(a1.type, 2)
        with self.assertRaises(AttributeError) as cm:
            a1.something

        # Test Action.__eq__, __ne__
        self.assertFalse(Action() == 'some string')
        self.assertTrue(Action() != 'some string')
        a2 = Action(text=1, type=2)
        a3 = Action(text=2, type=2)
        self.assertTrue(a1 == a2)
        self.assertFalse(a1 == a3)

        # Test Action.__str__
        self.assertEqual(str(a1), '<Action: datetime=None, text=1, type=2, '
                                  'activity=None, timelen=None, source=None>')

        # Test Action.is_action, is_event
        self.assertTrue(a1.is_action())
        self.assertFalse(a1.is_event())

        # Test Action.get_source (let's accept both tuples and lists as
        # sources)
        self.assertTrue(a1.get_source(), '<no_source>')
        a1.source = ('myfile', 42)
        self.assertTrue(a1.get_source(), 'file myfile line 42')
        a1.source = ['myfile', 42]
        self.assertTrue(a1.get_source(), 'file myfile line 42')

        # Test Action.__lt__
        d1 = str_to_datetime('1920-01-02 00:00:41')
        d2 = str_to_datetime('1920-01-02 00:00:42')
        a_1_start    = Action(type='start',    datetime=d1)
        a_1_stop     = Action(type='stop',     datetime=d1)
        a_1_interval = Action(type='interval', datetime=d1)
        a_1_target   = Action(type='target',   datetime=d1)
        a_2_start    = Action(type='start',    datetime=d2)
        a_2_stop     = Action(type='stop',     datetime=d2)
        a_2_interval = Action(type='interval', datetime=d2)
        a_2_target   = Action(type='target',   datetime=d2)

        # The "interval" comments below mean that the result of __lt__ in that
        # line can be explained by the fact that an interval action is always
        # less than a non-interval action.
        self.assertFalse(a_1_start < a_1_start)
        self.assertFalse(a_1_start < a_1_stop)
        self.assertFalse(a_1_start < a_1_interval)
        self.assertFalse(a_1_start < a_1_target)
        self.assertTrue (a_1_start < a_2_start)
        self.assertTrue (a_1_start < a_2_stop)
        self.assertFalse(a_1_start < a_2_interval)    # Interval
        self.assertTrue (a_1_start < a_2_target)

        self.assertFalse(a_1_stop < a_1_start)
        self.assertFalse(a_1_stop < a_1_stop)
        self.assertFalse(a_1_stop < a_1_interval)
        self.assertFalse(a_1_stop < a_1_target)
        self.assertTrue (a_1_stop < a_2_start)
        self.assertTrue (a_1_stop < a_2_stop)
        self.assertFalse(a_1_stop < a_2_interval)
        self.assertTrue (a_1_stop < a_2_target)

        self.assertTrue (a_1_interval < a_1_start)    # Interval
        self.assertTrue (a_1_interval < a_1_stop)     # Interval
        self.assertFalse(a_1_interval < a_1_interval)
        self.assertTrue (a_1_interval < a_1_target)   # Interval
        self.assertTrue (a_1_interval < a_2_start)
        self.assertTrue (a_1_interval < a_2_stop)
        self.assertTrue (a_1_interval < a_2_interval)
        self.assertTrue (a_1_interval < a_2_target)

        self.assertFalse(a_1_target < a_1_start)
        self.assertFalse(a_1_target < a_1_stop)
        self.assertFalse(a_1_target < a_1_interval)
        self.assertFalse(a_1_target < a_1_target)
        self.assertTrue (a_1_target < a_2_start)
        self.assertTrue (a_1_target < a_2_stop)
        self.assertFalse(a_1_target < a_2_interval)   # Interval
        self.assertTrue (a_1_target < a_2_target)

        self.assertFalse(a_2_start < a_1_start)
        self.assertFalse(a_2_start < a_1_stop)
        self.assertFalse(a_2_start < a_1_interval)
        self.assertFalse(a_2_start < a_1_target)
        self.assertFalse(a_2_start < a_2_start)
        self.assertFalse(a_2_start < a_2_stop)
        self.assertFalse(a_2_start < a_2_interval)
        self.assertFalse(a_2_start < a_2_target)

        self.assertFalse(a_2_stop < a_1_start)
        self.assertFalse(a_2_stop < a_1_stop)
        self.assertFalse(a_2_stop < a_1_interval)
        self.assertFalse(a_2_stop < a_1_target)
        self.assertFalse(a_2_stop < a_2_start)
        self.assertFalse(a_2_stop < a_2_stop)
        self.assertFalse(a_2_stop < a_2_interval)
        self.assertFalse(a_2_stop < a_2_target)

        self.assertTrue (a_2_interval < a_1_start)    # Interval
        self.assertTrue (a_2_interval < a_1_stop)     # Interval
        self.assertFalse(a_2_interval < a_1_interval)
        self.assertTrue (a_2_interval < a_1_target)   # Interval
        self.assertTrue (a_2_interval < a_2_start)    # Interval
        self.assertTrue (a_2_interval < a_2_stop)     # Interval
        self.assertFalse(a_2_interval < a_2_interval) # Interval
        self.assertTrue (a_2_interval < a_2_target)   # Interval

        self.assertFalse(a_2_target < a_1_start)
        self.assertFalse(a_2_target < a_1_stop)
        self.assertFalse(a_2_target < a_1_interval)
        self.assertFalse(a_2_target < a_1_target)
        self.assertFalse(a_2_target < a_2_start)
        self.assertFalse(a_2_target < a_2_stop)
        self.assertFalse(a_2_target < a_2_interval)
        self.assertFalse(a_2_target < a_2_target)

        # Test Action.__gt__, __le__, __ge__

        with self.assertRaises(AssertionError):
            a_1_start > a_1_start

        with self.assertRaises(AssertionError):
            a_1_start <= a_1_start

        with self.assertRaises(AssertionError):
            a_1_start >= a_1_start

        # Test Action.calc

        def t(text, expected_result, expected_type, expected_activity,
              expected_timelen):
            action = Action(text=text)
            self.assertEqual(action.calc(), expected_result)
            self.assertEqual(action.type, expected_type)
            self.assertEqual(action.activity, expected_activity)
            self.assertEqual(action.timelen, expected_timelen)

        t('', False, None, None, None)
        t('stop', True, 'stop', None, None)
        t('work', True, 'start', 'work', None)
        t('increase-target work 2', True, 'target', 'work', 2 * 60)
        t('increase-target work 2:3', True, 'target', 'work', 2 * 3600 + 3 * 60)
        t('increase-target work 2:3:4', True, 'target', 'work',
          2 * 3600 + 3 * 60 + 4)
        t('2 work', True, 'interval', 'work', 2 * 60)
        t('2:3 work', True, 'interval', 'work', 2 * 3600 + 3 * 60)
        t('2:3:4 work', True, 'interval', 'work', 2 * 3600 + 3 * 60 + 4)
        self.assertOutput('')

        t('bad line', False, None, None, None)
        self.assertOutput('WARNING: Incorrect action in <no_source>: bad line')

        # Test Action.between
        d1 = str_to_date('1920-01-01')
        d2 = str_to_date('1920-01-02')
        d2dt = str_to_datetime('1920-01-02 01:01:01')
        d3 = str_to_date('1920-01-03')
        a2 = Action(datetime=d2dt)
        self.assertFalse(a2.between(d1, d1))
        self.assertTrue (a2.between(d1, d2))
        self.assertTrue (a2.between(d1, d3))
        self.assertTrue (a2.between(d1, None))
        self.assertFalse(a2.between(d2, d1))
        self.assertTrue (a2.between(d2, d2))
        self.assertTrue (a2.between(d2, d3))
        self.assertTrue (a2.between(d2, None))
        self.assertFalse(a2.between(d3, d1))
        self.assertFalse(a2.between(d3, d2))
        self.assertFalse(a2.between(d3, d3))
        self.assertFalse(a2.between(d3, None))
        self.assertFalse(a2.between(None, d1))
        self.assertTrue (a2.between(None, d2))
        self.assertTrue (a2.between(None, d3))
        self.assertTrue (a2.between(None, None))

    def test_Event(self):

        # Test Event.__init__
        e1 = Event(starttime=1, stoptime=2, something=4)
        e2 = Event(starttime=1, stoptime=2, ongoing=3, something=4)
        self.assertEqual(e1.starttime, 1)
        self.assertEqual(e1.stoptime, 2)
        self.assertEqual(e1.ongoing, False)
        self.assertEqual(e2.ongoing, 3)
        with self.assertRaises(AttributeError) as cm:
            e1.something

        # Test Event.__eq__, __ne__
        self.assertFalse(Event() == 'some string')
        self.assertTrue(Event() != 'some string')
        e2 = Event(starttime=1, stoptime=2)
        e3 = Event(starttime=2, stoptime=2)
        self.assertTrue(e1 == e2)
        self.assertFalse(e1 == e3)

        # Test Event.__str__
        self.assertEqual(str(e1), '<Event: starttime=1, stoptime=2, '
                                  'activity=None, timelen=None, ongoing=False, '
                                  'is_interval_action=False>')

        # Test Event.is_action, is_event
        self.assertFalse(e1.is_action())
        self.assertTrue(e1.is_event())

        # Test Event.between
        d1 = str_to_date('1920-01-01')
        d2 = str_to_date('1920-01-02')
        d2dt = str_to_datetime('1920-01-02 01:01:01')
        d3 = str_to_date('1920-01-03')
        e = Event(starttime=d2dt)
        self.assertFalse(e.between(d1, d1))
        self.assertTrue (e.between(d1, d2))
        self.assertTrue (e.between(d1, d3))
        self.assertTrue (e.between(d1, None))
        self.assertFalse(e.between(d2, d1))
        self.assertTrue (e.between(d2, d2))
        self.assertTrue (e.between(d2, d3))
        self.assertTrue (e.between(d2, None))
        self.assertFalse(e.between(d3, d1))
        self.assertFalse(e.between(d3, d2))
        self.assertFalse(e.between(d3, d3))
        self.assertFalse(e.between(d3, None))
        self.assertFalse(e.between(None, d1))
        self.assertTrue (e.between(None, d2))
        self.assertTrue (e.between(None, d3))
        self.assertTrue (e.between(None, None))

    ##### Action file handling #####

    def test_split_comment(self):

        self.assertEqual(split_comment(''), ('', ''))
        self.assertEqual(split_comment('abc'), ('abc', ''))

        self.assertEqual(split_comment('abc#'), ('abc#', ''))
        self.assertEqual(split_comment('abc #'), ('abc', ''))
        self.assertEqual(split_comment('abc  # '), ('abc', ''))

        self.assertEqual(split_comment('abc # def'), ('abc', 'def'))
        self.assertEqual(split_comment('abc ## def'), ('abc', '# def'))
        self.assertEqual(split_comment('abc# def'), ('abc# def', ''))
        self.assertEqual(split_comment('abc #def'), ('abc', 'def'))
        self.assertEqual(split_comment('abc#def'), ('abc#def', ''))

        self.assertEqual(split_comment('abc # def # 123'), ('abc', 'def # 123'))
        self.assertEqual(split_comment('abc ## def ## 123'),
                         ('abc', '# def ## 123'))

        self.assertEqual(split_comment('abc\t#\tdef'), ('abc', 'def'))
        self.assertEqual(split_comment('abc \t # \t def'), ('abc', 'def'))

    def test_process_action_file_line(self):
        l = []

        process_actionfile_line('datetime', '', l, 'source')
        self.assertEqual(l, [])

        process_actionfile_line('datetime', 'act # comment', l, 'source')
        self.assertEqual(l, [Action(datetime='datetime',
                                    text='act',
                                    type='start',
                                    activity='act',
                                    timelen=None,
                                    source='source')])

    def test_get_categories(self):

        self.assertEqual(get_categories('ab'), ['ab'])
        self.assertEqual(get_categories('a/b/c'), ['a', 'a/b', 'a/b/c'])

    ##### Functions reading the action files #####

    def test_actionfile(self):

        filename = self.create_action_file('''
                       [2000-01-01 00:00:00] mywork

                       # Comment
                       [2000-01-01 00:10:00] myotherwork
                       [2000-01-01 00:11:00] 4 myotherwork
                       [2000-01-01 00:12:00] increase-target mywork 5
                       [2000-01-01 00:20:00] stop''')

        # Actions
        actual_actions = parse_actionfile(filename)
        expected_actions = [
            Action(datetime=str_to_datetime("2000-01-01 00:00:00"),
                   text='mywork', type='start',
                   activity='mywork', source=(filename, 1)),
            Action(datetime=str_to_datetime("2000-01-01 00:10:00"),
                   text='myotherwork', type='start',
                   activity='myotherwork', source=(filename, 4)),
            Action(datetime=str_to_datetime("2000-01-01 00:11:00"),
                   text='4 myotherwork', type='interval',
                   activity='myotherwork', timelen=60 * 4,
                   source=(filename, 5)),
            Action(datetime=str_to_datetime("2000-01-01 00:12:00"),
                   text='increase-target mywork 5', type='target',
                   activity='mywork', timelen=60 * 5, source=(filename, 6)),
            Action(datetime=str_to_datetime("2000-01-01 00:20:00"),
                   text='stop', type='stop', source=(filename, 7))]
        self.assertEqual(actual_actions, expected_actions)

        # Happenings
        actual_happenings = collect_happenings(self.options, actual_actions)
        expected_happenings = [
            Event(starttime=str_to_datetime("2000-01-01 00:00:00"),
                  stoptime=str_to_datetime("2000-01-01 00:10:00"),
                  activity='mywork',
                  timelen=60 * 10),
            Event(starttime=str_to_datetime("2000-01-01 00:10:00"),
                  stoptime=str_to_datetime("2000-01-01 00:20:00"),
                  activity='myotherwork',
                  timelen=60 * 10),
            Event(starttime=str_to_datetime("2000-01-01 00:11:00"),
                  stoptime=str_to_datetime("2000-01-01 00:15:00"),
                  activity='myotherwork',
                  timelen=60 * 4, is_interval_action=True),
            Action(datetime=str_to_datetime("2000-01-01 00:12:00"),
                   text='increase-target mywork 5', type='target',
                   activity='mywork', timelen=60 * 5,
                   source=(filename, 6))]
        self.assertEqual(actual_happenings, expected_happenings)

        # Events
        actual_events = collect_events(self.options, actual_happenings)
        expected_events = [
            Event(starttime=str_to_datetime("2000-01-01 00:00:00"),
                  stoptime=str_to_datetime("2000-01-01 00:10:00"),
                  activity='mywork',
                  timelen=60 * 10),
            Event(starttime=str_to_datetime("2000-01-01 00:10:00"),
                  stoptime=str_to_datetime("2000-01-01 00:20:00"),
                  activity='myotherwork',
                  timelen=60 * 10),
            Event(starttime=str_to_datetime("2000-01-01 00:11:00"),
                  stoptime=str_to_datetime("2000-01-01 00:15:00"),
                  activity='myotherwork',
                  timelen=60 * 4, is_interval_action=True)]
        self.assertEqual(actual_events, expected_events)

        # Activities
        actual_activities = collect_activities(self.options, actual_events)

        # Targets
        actual_targets = collect_targets(self.options,
                                         actual_happenings,
                                         actual_activities)
        expected_targets = {'mywork': {'target_timelen': 60 * 5,
                                       'actual_timelen': 60 * 10}}
        self.assertEqual(actual_targets, expected_targets)

    def test_ongoing_activity(self):

        filename = self.create_action_file('''
                       [2000-01-01 00:00:00] mywork''')

        # Actions
        actual_actions = parse_actionfile(filename)
        expected_actions = [
            Action(datetime=str_to_datetime("2000-01-01 00:00:00"),
                   text='mywork', type='start',
                   activity='mywork', source=(filename, 1))]
        self.assertEqual(actual_actions, expected_actions)

        # Happenings
        now = datetime.datetime(2000, 1, 1, 0, 5, 0)
        actual_happenings = collect_happenings(self.options,
                                               actual_actions, now=now)
        expected_happenings = [
            Event(starttime=str_to_datetime("2000-01-01 00:00:00"),
                  stoptime=str_to_datetime("2000-01-01 00:05:00"),
                  activity='mywork',
                  timelen=60 * 5, ongoing=True)]
        self.assertEqual(actual_happenings, expected_happenings)

        # Events
        actual_events = collect_events(self.options, actual_happenings)
        expected_events = expected_happenings
        self.assertEqual(actual_events, expected_events)

    def test_collect_activities_hotness(self):

        filename = self.create_action_file('''
                       [2000-01-01 00:00:00] a
                       [2000-01-02 00:00:00] c
                       [2000-01-03 00:00:00] b
                       [2000-01-04 00:00:00] a
                       [2000-01-01 01:00:00] e
                       ''')

        # Actions
        actions = collect_actions(self.options)
        happenings = collect_happenings(self.options, actions)
        events = collect_events(self.options, happenings)

        actual_act_hot = collect_activities_hotness(self.options, happenings)
        expected_act_hot = ['a', 'b', 'c', 'e']
        self.assertEqual(actual_act_hot, expected_act_hot)

    def test_ignore_and_only(self):

        self.create_action_file('''
            [2000-01-01 00:00:00] work
            [2000-01-01 00:10:00] myotherwork
            [2000-01-01 00:11:00] something_else
            [2000-01-01 00:12:00] increase-target work 5
            [2000-01-01 00:20:00] stop''')

        def t(ign, ign_pat, only, only_pat, expected_activities):
            self.options.ignore_activities = ign
            self.options.ignore_activities_pattern = ign_pat
            self.options.only_activities = only
            self.options.only_activities_pattern = only_pat
            _, _, _, actual_activities = collect_everything(self.options)
            self.assertEqual(actual_activities, expected_activities)

        # Basic test
        t(None, None, None, None,
          {'work': 600.0,
           'myotherwork': 60.0,
           'something_else': 540.0})

        # Ignore
        t(['work'], None, None, None,
          {'myotherwork': 60.0,
           'something_else': 540.0})
        main_core(['show', '-i', 'work', '--nosum'])
        self.assertOutput('myotherwork: 00:01',
                          'something_else: 00:09')

        # Ignore
        t(['work', 'myotherwork'], None, None, None,
          {'something_else': 540.0})


        # Ignore pattern
        t(None, 'work', None, None,
          {'something_else': 540.0})
        main_core(['show', '-I', 'work', '--nosum'])
        self.assertOutput('something_else: 00:09')

        # "Only"
        t(None, None, ['work'], None,
          {'work': 600.0})
        main_core(['show', '-o', 'work', '--nosum'])
        self.assertOutput('work: 00:10')

        # "Only"
        t(None, None, ['work', 'myotherwork'], None,
          {'work': 600.0,
           'myotherwork': 60.0})

        # "Only" pattern
        t(None, None, None, 'work',
          {'work': 600.0,
           'myotherwork': 60.0})
        main_core(['show', '-O', 'work', '--nosum'])
        self.assertOutput('myotherwork: 00:01',
                          'work: 00:10')

        # "Only" pattern
        t(None, None, None, 'o.*t',
          {'myotherwork': 60.0,
           'something_else': 540.0})

        # "Ignore" + "Only" pattern
        t(None, 'work', None, 'o.*t',
          {'something_else': 540.0})

    def test_erroneous_action_file(self):

        filename = self.create_action_file('bad_content')

        show(self.options)
        self.assertOutput(
            'WARNING: Incorrect line in file %s line 0: bad_content\n'
            'Sum: 00:00' % filename)

    def test_show_status(self):

        self.create_action_file('')
        main_core(['show-status'])
        self.assertOutput('No event found.')

        self.create_action_file('''[1999-01-01 00:10:00] mywork''')
        self.now = [1999, 1, 1, 0, 15, 0]
        main_core(['show-status'])
        self.assertOutput('State: on',
                          'Current activity: mywork',
                          'Start time: 00:10',
                          'Current time: 00:15',
                          'Time since started: 00:05')

        self.create_action_file('''[1999-01-01 00:10:00] mywork
                                   [1999-01-01 00:15:00] stop''')
        self.now = [1999, 1, 1, 0, 20, 0]
        main_core(['show-status'])
        self.assertOutput('State: off',
                          'Last activity: mywork',
                          'Start time: 00:10',
                          'Stop time: 00:15',
                          'Time length: 00:05')

    def test_show_targets(self):
        self.create_action_file(
            '''[1999-01-01 00:00:00] mywork
               [1999-01-01 01:00:00] stop
               [1999-01-02 02:00:00] 20 mywork
               [1999-01-03 00:00:00] myotherwork
               [1999-01-03 00:00:00] stop
               [1999-01-04 00:00:00] 0:10 myotherwork
               [1999-01-05 00:00:00] increase-target mywork 1:00
               [1999-01-05 00:00:00] increase-target mywork 2:00

               [1999-01-05 00:00:00] increase-target reading 1
               [1999-01-05 00:00:00] 10 reading

               [1999-01-05 00:00:00] increase-target writing 1

               # The future does not count:
               [1999-02-02 00:00:00] mywork
               [1999-02-02 23:00:00] stop
               [1999-02-03 00:00:00] 25:00 mywork
               [1999-02-04 00:00:00] increase-target mywork 100:00''')

        self.now = [1999, 2, 1, 0, 15, 0]
        main_core(['show-targets'])
        self.assertOutput('Target name: mywork',
                          'Target time: 03:00',
                          'Actual time: 01:20',
                          'Difference: -01:40',
                          '',
                          'Target name: reading',
                          'Target time: 00:01',
                          'Actual time: 00:10',
                          'Difference: 00:09',
                          '',
                          'Target name: writing',
                          'Target time: 00:01',
                          'Actual time: 00:00',
                          'Difference: -00:01')

    def test_print_object(self):

        self.create_action_file('''[1999-01-01 20:00:00] mywork
                                   [1999-01-01 20:20:00] myotherwork''')

        main_core(['print', 'actions'])
        self.assertOutput(
            "<Action: datetime=1999-01-01 20:00:00, "
            "text=mywork, type=start, "
            "activity=mywork, timelen=None, source=('"
            + self.tmpfile + "', 0)>\n"
            "<Action: datetime=1999-01-01 20:20:00, "
            "text=myotherwork, type=start, activity=myotherwork, timelen=None, "
            "source=('" + self.tmpfile + "', 1)>")

        main_core(['print', 'happenings'])
        self.assertOutput(
            "<Event: starttime=1999-01-01 20:00:00, "
            "stoptime=1999-01-01 20:20:00, activity=mywork, "
            "timelen=1200, ongoing=False, is_interval_action=False>\n"
            "<Event: starttime=1999-01-01 20:20:00, "
            "stoptime=2000-01-01 00:00:00, activity=myotherwork, "
            "timelen=31462800, ongoing=True, is_interval_action=False>")

        main_core(['print', 'events'])
        self.assertOutput(
            "<Event: starttime=1999-01-01 20:00:00, "
            "stoptime=1999-01-01 20:20:00, activity=mywork, "
            "timelen=1200, ongoing=False, is_interval_action=False>\n"
            "<Event: starttime=1999-01-01 20:20:00, "
            "stoptime=2000-01-01 00:00:00, activity=myotherwork, "
            "timelen=31462800, ongoing=True, is_interval_action=False>")

        main_core(['print', 'activities'])
        self.assertOutput("('myotherwork', 31462800)\n"
                          "('mywork', 1200)")


    def test_show_c(self):

        self.now = [1999, 1, 2, 0, 0, 0]
        self.create_action_file('')
        main_core(['show', '-c'])
        self.assertOutput('')

        self.create_action_file('''[1999-01-01 20:00:00] mywork''')
        main_core(['show', '-c'])
        self.assertOutput('mywork: 04:00')

        self.create_action_file('''[1999-01-01 20:00:00] 10 mywork''')
        main_core(['show', '-c'])
        self.assertOutput('')

        self.create_action_file('''[1999-01-01 20:00:00] mywork
                                   [1999-01-01 20:20:00] stop''')
        main_core(['show', '-c'])
        self.assertOutput('')

    def test_show(self):

        self.create_action_file(
            '''[1872-03-18 20:00:00] mywork
               [1872-03-18 20:20:00] myotherwork
               [1872-03-18 20:40:00] mywork
               [1872-03-18 20:45:00] stop
               [1872-03-18 20:55:00] myotherwork
               [1872-03-18 21:05:00] stop
               [1872-03-18 22:05:00] 10 myotherwork
               [1872-03-25 22:05:00] 10 myotherwork
               [1872-04-01 22:05:00] 1:00 myotherwork
               [1872-04-08 22:05:00] 1:30 myotherwork
               [1872-04-22 22:05:00] 2:00 myotherwork
               [1872-04-22 22:05:00] increase-target mywork 10''')

        self.now = [1872, 5, 10, 0, 0, 0]

        # show

        main_core(['show'])
        self.assertOutput('myotherwork: 05:20',
                          'mywork: 00:25',
                          'Sum: 05:45')

        main_core([]) # show is the default command
        self.assertOutput('myotherwork: 05:20',
                          'mywork: 00:25',
                          'Sum: 05:45')

        main_core(['show', '--nosum'])
        self.assertOutput('myotherwork: 05:20',
                          'mywork: 00:25')

        main_core(['show', '--sum'])
        self.assertOutput('Sum: 05:45')

        main_core(['show', '--only-expr',
                   'h.is_event() and int(h.starttime.strftime("%H")) <= 20'])
        self.assertOutput('myotherwork: 00:30',
                          'mywork: 00:25',
                          'Sum: 00:55')

        # show-sum daily

        main_core(['show-sum', 'daily'])
        self.assertOutput('1872-03-18 x',
                          '1872-03-25',
                          '1872-04-01 x',
                          '1872-04-08 x',
                          '1872-04-22 xx')

        main_core(['show-sum', 'daily', '--show-time'])
        self.assertOutput('1872-03-18 (01:05) x',
                          '1872-03-25 (00:10)',
                          '1872-04-01 (01:00) x',
                          '1872-04-08 (01:30) x',
                          '1872-04-22 (02:00) xx')

        # --fill

        main_core(['show-sum', 'daily', '--fill', '--show-time',
                   '--from', '1872-03-17',
                   '--to', '1872-03-26'])
        self.assertOutput('1872-03-17 (00:00)',
                          '1872-03-18 (01:05) x',
                          '1872-03-19 (00:00)',
                          '1872-03-20 (00:00)',
                          '1872-03-21 (00:00)',
                          '1872-03-22 (00:00)',
                          '1872-03-23 (00:00)',
                          '1872-03-24 (00:00)',
                          '1872-03-25 (00:10)',
                          '1872-03-26 (00:00)')

        main_core(['show-sum', 'daily', '--fill', '--show-time',
                   '--to', '1872-03-26'])
        self.assertOutput('1872-03-18 (01:05) x',
                          '1872-03-19 (00:00)',
                          '1872-03-20 (00:00)',
                          '1872-03-21 (00:00)',
                          '1872-03-22 (00:00)',
                          '1872-03-23 (00:00)',
                          '1872-03-24 (00:00)',
                          '1872-03-25 (00:10)',
                          '1872-03-26 (00:00)')

        # --avg

        main_core(['show-sum', 'daily', '--avg'])
        self.assertOutput('1872-03-18 x',
                          '1872-03-25',
                          '1872-04-01 x',
                          '1872-04-08 x',
                          '1872-04-22 xx',
                          'Average: 01:09')

        main_core(['show-sum', 'daily', '--fill',
                   '--from', '1872-03-17',
                   '--to', '1872-03-26',
                   '--avg', '--seconds'])
        self.assertOutput('1872-03-17',
                          '1872-03-18 x',
                          '1872-03-19',
                          '1872-03-20',
                          '1872-03-21',
                          '1872-03-22',
                          '1872-03-23',
                          '1872-03-24',
                          '1872-03-25',
                          '1872-03-26',
                          'Average: 00:07:30')

        # --block-seconds
        main_core(['show-sum', 'daily', '--block-seconds', '600'])
        self.assertOutput('1872-03-18 xxxxxx',
                          '1872-03-25 x',
                          '1872-04-01 xxxxxx',
                          '1872-04-08 xxxxxxxxx',
                          '1872-04-22 xxxxxxxxxxxx')

        # show-sum weekly

        main_core(['show-sum', 'weekly'])
        self.assertOutput('1872-w12 x',
                          '1872-w13',
                          '1872-w14 x',
                          '1872-w15 x',
                          '1872-w17 xx')

        main_core(['show-sum', 'weekly', '--show-time'])
        self.assertOutput('1872-w12 (01:05) x',
                          '1872-w13 (00:10)',
                          '1872-w14 (01:00) x',
                          '1872-w15 (01:30) x',
                          '1872-w17 (02:00) xx')

        main_core(['show-sum', 'weekly', '--fill'])
        self.assertOutput('1872-w12 x',
                          '1872-w13',
                          '1872-w14 x',
                          '1872-w15 x',
                          '1872-w16',
                          '1872-w17 xx',
                          '1872-w18',
                          '1872-w19')

        main_core(['show-sum', 'weekly', '--to', 'w14-6'])
        self.assertOutput('1872-w12 x',
                          '1872-w13',
                          '1872-w14 x')

        main_core(['show-sum', 'weekly', '--fill', '--from', '1872-w14-1'])
        self.assertOutput('1872-w14 x',
                          '1872-w15 x',
                          '1872-w16',
                          '1872-w17 xx',
                          '1872-w18',
                          '1872-w19')

        main_core(['show-sum', 'weekly', '--fill', '--to', '1870-w14-1'])
        self.assertOutput('')

        main_core(['show', '-w'])
        self.assertOutput('1872-w12 x',
                          '1872-w13',
                          '1872-w14 x',
                          '1872-w15 x',
                          '1872-w17 xx')

        # show-monthly-sum

        main_core(['show-sum', 'monthly'])
        self.assertOutput('1872-03 x',
                          '1872-04 xxxx')

        main_core(['show-sum', 'monthly', '--fill'])
        self.assertOutput('1872-03 x',
                          '1872-04 xxxx')


    def test_since_until(self):

        self.create_action_file('''[1999-01-01 01:00:00] 10 work1
                                   [1999-01-02 01:00:00] 10 work2
                                   [1999-01-03 01:00:00] 12 work1
                                   [1999-01-04 01:00:00] 15 work3''')

        main_core(['show', '--from', '1999-01-02', '--nosum'])
        self.assertOutput('work1: 00:12',
                          'work2: 00:10',
                          'work3: 00:15')

        main_core(['show', '--to', '1999-01-02', '--nosum'])
        self.assertOutput('work1: 00:10',
                          'work2: 00:10')

        main_core(['show', '--from', '1999-01-02',
                           '--to', '1999-01-03', '--nosum'])
        self.assertOutput('work1: 00:12',
                          'work2: 00:10')

        self.now = [1999, 1, 3, 12, 0, 0]
        main_core(['show', '--today', '--nosum'])
        self.assertOutput('work1: 00:12')

        main_core(['show', '--yesterday', '--nosum'])
        self.assertOutput('work2: 00:10')

        main_core(['show', '--day', 'yy', '--nosum'])
        self.assertOutput('work1: 00:10')

        with self.assertRaises(Exit) as cm:
            main_core(['show', '--from', '1999-01-02',
                               '--to', '1999-01-01'])
        self.assertExit(cm, 1, '"From" date (1999-01-02) is after "to" '
                               'date (1999-01-01).')


    def test_week(self):

        self.create_action_file('''[2014-02-02 01:00:00] 10 work1
                                   [2014-02-03 01:00:00] 1 work1
                                   [2014-02-04 01:00:00] 1 work1
                                   [2014-02-09 01:00:00] 1 work1
                                   [2014-02-10 01:00:00] 10 work1''')

        main_core(['show', '--week', '2014-06', '--nosum'])
        self.assertOutput('work1: 00:03')

    ##### Functions writing the action files #####

    def test_add(self):

        self.create_action_file('')

        # Test the example in the README
        self.now = [2009, 7, 25, 20, 0, 0]
        main_core(['add', 'mywork', '-v'])
        self.assertOutput(self.tmpfile + ' extended with: '
                          '[2009-07-25 20:00:00] mywork')

        self.now = [2009, 7, 25, 20, 20, 0]
        main_core(['add', 'myotherwork'])

        self.now = [2009, 7, 25, 20, 40, 0]
        main_core(['add', 'mywork'])

        self.now = [2009, 7, 25, 20, 45, 0]
        main_core(['add', 'stop'])

        self.now = [2009, 7, 25, 20, 55, 0]
        main_core(['add', 'mywork'])

        self.now = [2009, 7, 25, 21, 5, 0]
        main_core(['add', 'stop'])

        self.now = [2009, 7, 25, 22, 5, 0]
        main_core(['add', '10', 'myotherwork'])

        self.assertEqual(self.read_action_file(),
                         '[2009-07-25 20:00:00] mywork\n'
                         '[2009-07-25 20:20:00] myotherwork\n'
                         '[2009-07-25 20:40:00] mywork\n'
                         '[2009-07-25 20:45:00] stop\n'
                         '[2009-07-25 20:55:00] mywork\n'
                         '[2009-07-25 21:05:00] stop\n'
                         '[2009-07-25 22:05:00] 10 myotherwork\n')

        main_core(['show'])
        self.assertOutput('myotherwork: 00:30',
                          'mywork: 00:35',
                          'Sum: 01:05')
        # Test ALL
        with self.assertRaises(Exit) as cm:
            main_core(['add', 'work', '--actionfile', 'ALL'])
        self.assertExit(cm, 1, 'Action file "ALL" is not accepted by "add".')

    def test_quickadd(self):

        self.create_action_file('')

        with self.assertRaises(Exit) as cm:
            quickadd(self.options, ''),
        self.assertExit(cm, 1, 'Empty activity specified.')

        with self.assertRaises(Exit) as cm:
            main_core(['quickadd'])
        self.assertExit(cm, 1, 'Action file does not contain any event.')

        # Test the example in the README
        self.now = [2009, 7, 25, 20, 0, 0]
        main_core(['quickadd', 'mywork'])
        self.assertOutput('"mywork" activity started')

        self.now = [2009, 7, 25, 20, 20, 0]
        main_core(['quickadd', 'myotherwork'])
        self.assertOutput('"myotherwork" activity started, '
                          '"mywork" activity stopped')

        self.now = [2009, 7, 25, 20, 40, 0]
        main_core(['quickadd'])
        self.assertOutput('"mywork" activity resumed, '
                          '"myotherwork" activity stopped')

        self.now = [2009, 7, 25, 20, 45, 0]
        main_core(['quickadd', 'stop'])
        self.assertOutput('"mywork" activity stopped')

        self.now = [2009, 7, 25, 20, 55, 0]
        main_core(['quickadd'])
        self.assertOutput('"mywork" activity resumed')

        self.now = [2009, 7, 25, 20, 56, 0]
        main_core(['quickadd', 'mywork'])
        self.assertOutput('Do nothing: "mywork" activity is going on anyway.')

        self.now = [2009, 7, 25, 21, 5, 0]
        main_core(['quickadd'])
        self.assertOutput('"mywork" activity stopped')

        self.now = [2009, 7, 25, 22, 0, 0]
        main_core(['quickadd', 'stop'])
        self.assertOutput('Do nothing: there is nothing to stop.')

        self.now = [2009, 7, 25, 22, 5, 0]
        main_core(['quickadd', '10', 'myotherwork'])
        self.assertOutput('')

        self.assertEqual(self.read_action_file(),
                         '[2009-07-25 20:00:00] mywork\n'
                         '[2009-07-25 20:20:00] myotherwork\n'
                         '[2009-07-25 20:40:00] mywork\n'
                         '[2009-07-25 20:45:00] stop\n'
                         '[2009-07-25 20:55:00] mywork\n'
                         '[2009-07-25 21:05:00] stop\n'
                         '[2009-07-25 22:05:00] 10 myotherwork\n')

        main_core(['show'])
        self.assertOutput('myotherwork: 00:30',
                          'mywork: 00:35',
                          'Sum: 01:05')

        # Redundant start/resume
        self.create_action_file('[2000-01-01 00:00:00] mywork\n'
                                '[2000-01-01 00:00:01] stop\n')

        self.now = [2000, 1, 1, 0, 0, 2]
        main_core(['quickadd', 'mywork'])
        self.assertOutput('"mywork" activity resumed')

        self.now = [2000, 1, 1, 0, 0, 3]
        main_core(['quickadd', 'stop'])
        self.assertOutput('"mywork" activity stopped')

        self.now = [2000, 1, 1, 0, 0, 4]
        main_core(['quickadd', 'myotherwork'])
        self.assertOutput('"myotherwork" activity started')

        self.now = [2000, 1, 1, 0, 0, 5]
        main_core(['quickadd', 'stop'])
        self.assertOutput('"myotherwork" activity stopped')

        self.assertEqual(self.read_action_file(),
                         '[2000-01-01 00:00:00] mywork\n'
                         '[2000-01-01 00:00:01] stop\n'
                         '[2000-01-01 00:00:02] mywork\n'
                         '[2000-01-01 00:00:03] stop\n'
                         '[2000-01-01 00:00:04] myotherwork\n'
                         '[2000-01-01 00:00:05] stop\n')


    def test_edit(self):
        with self.assertRaises(Exit) as cm:
            main_core(['edit'])
        self.assertExit(cm, 1, 'You should set the $EDITOR environment '
                               'variable to your favorite text editor.')
        os.environ['EDITOR'] = 'myeditor'
        main_core(['edit'])
        self.assertCalls([['myeditor', 'mock_actionfile_name']])

        main_core(['edit', '-a', 'ALL'])
        self.assertCalls([['myeditor', 'mock_actionfile_name']])

        main_core(['edit', '-a', 'ALL', '-f', '1:2:3'])
        self.assertCalls([['myeditor', '1', '2', '3']])

        main_core(['edit', '-a', 'sec', '-f', 'first:second:third'])
        self.assertCalls([['myeditor', 'second']])

        with self.assertRaises(Exit) as cm:
            main_core(['edit', '-a', 'nosuch', '-f', 'my1:my2'])
        self.assertExit(cm, 1, "Cannot find action file in action file list.\n"
                               "Action file: nosuch\n"
                               "Action file list: ['my1', 'my2']")

        with self.assertRaises(Exit) as cm:
            main_core(['edit', '-a', 'my', '-f', 'my1:my2'])
        self.assertExit(cm, 1, "More than one action files match.\n"
                               "Action file: my\n"
                               "Action file list: ['my1', 'my2']")

    def test_list_actionfiles(self):
        main_core(['list'])
        self.assertOutput('mock_actionfile_name')

        main_core(['list', '-f', '1:2:3'])
        self.assertOutput('1\n2\n3')

    def test_expand_activity(self):

        activities = ['myotherwork',
                      'something_else',
                      'work']

        self.assertEqual(expand_activity('%other', activities),
                         'myotherwork')

        with self.assertRaises(Exit) as cm:
            expand_activity('%nomatch', activities)
        self.assertExit(cm, 1, 'No activity matches "nomatch"')

        # stdin mock
        class NewStdin():
            def __init__(self, l):
                self.i = 0
                self.l = l
            def readline(self):
                self.i += 1
                return self.l[self.i - 1]

        real_stdin = sys.stdin
        try:

            # Cancelling
            with self.assertRaises(Exit) as cm:
                sys.stdin = NewStdin([''])
                self.assertEqual(expand_activity('%work', activities),
                                 'myotherwork')
            self.assertOutput(
                'Select the desired match (empty line = cancel):',
                '1: myotherwork',
                '2: work',
                '>')
            self.assertExit(cm, 0, 'Cancelled.')

            # Select one of the hits
            sys.stdin = NewStdin(['1'])
            self.assertEqual(expand_activity('%work', activities),
                             'myotherwork')
            self.assertOutput(
                'Select the desired match (empty line = cancel):',
                '1: myotherwork',
                '2: work',
                '>')

            # Trying several times
            sys.stdin = NewStdin(['0', '3', 'xy', '1'])
            self.assertEqual(expand_activity('%work', activities),
                             'myotherwork')
            self.assertOutput(
                'Select the desired match (empty line = cancel):',
                '1: myotherwork',
                '2: work',
                '> Please type one of the numbers above or an empty line to '
                'cancel.',
                '> Please type one of the numbers above or an empty line to '
                'cancel.',
                '> Please type one of the numbers above or an empty line to '
                'cancel.',
                '>')

        finally:
            sys.stdin = real_stdin

    def test_full_help(self):
        main_core(['full-help'])
        try:
            self.assertEqual(self.output[:15], '**Timestat** is')
            self.assertEqual(self.output[-3:], 'fi\n')
        finally:
            self.output = ''

    ##### Test the command line interface #####

    def test_no_action_file(self):

        os.environ['ACTIONFILES'] = ''
        with self.assertRaises(Exit) as cm:
            main_core(['nosuchcommand'])
        self.assertExit(cm, 1, 'You should set either the ACTIONFILES '
                               'environment variable or give --actionfiles '
                               'argument!')

    def test_check_args(self):

        def ok(a, b, arg_count):
            check_args(['cmd'] + ['arg'] * arg_count, a, b)

        def err(a, b, arg_count, msg):
            with self.assertRaises(Exit) as cm:
                check_args(['cmd'] + ['arg'] * arg_count, a, b)
            self.assertExit(cm, 1, msg)

        ok (0, 0, 0)
        ok (0, None, 0)
        err(0, 0, 1, 'The "cmd" command requires no argument.')
        err(0, 0, 2, 'The "cmd" command requires no argument.')
        ok (0, 1, 0)
        ok (0, 1, 1)
        err(0, 1, 2, 'The "cmd" command requires at most 1 argument.')
        err(0, 1, 3, 'The "cmd" command requires at most 1 argument.')
        ok (0, 2, 0)
        ok (0, 2, 1)
        ok (0, 2, 2)
        err(0, 2, 3, 'The "cmd" command requires at most 2 arguments.')
        ok (0, 3, 0)
        ok (0, 3, 1)
        ok (0, 3, 2)
        ok (0, 3, 3)
        err(1, 1, 0, 'The "cmd" command requires exactly 1 argument.')
        ok (1, 1, 1)
        ok (1, None, 1)
        err(1, 1, 2, 'The "cmd" command requires exactly 1 argument.')
        err(1, 1, 3, 'The "cmd" command requires exactly 1 argument.')
        err(1, 2, 0, 'The "cmd" command requires at least 1 argument.')
        ok (1, 2, 1)
        ok (1, 2, 2)
        err(1, 2, 3, 'The "cmd" command requires at most 2 arguments.')
        err(1, 3, 0, 'The "cmd" command requires at least 1 argument.')
        ok (1, 3, 1)
        ok (1, 3, 2)
        ok (1, 3, 3)
        err(2, 2, 0, 'The "cmd" command requires exactly 2 arguments.')
        err(2, 2, 1, 'The "cmd" command requires exactly 2 arguments.')
        ok (2, 2, 2)
        ok (2, None, 2)
        err(2, 2, 3, 'The "cmd" command requires exactly 2 arguments.')
        err(2, 3, 0, 'The "cmd" command requires at least 2 arguments.')
        err(2, 3, 1, 'The "cmd" command requires at least 2 arguments.')
        ok (2, 3, 2)
        ok (2, 3, 3)

        with self.assertRaises(Exit) as cm:
            main_core(['full-help', 'x'])
        self.assertExit(cm, 1, 'The "full-help" command requires no argument.')

        with self.assertRaises(Exit) as cm:
            main_core(['add'])
        self.assertExit(cm, 1, 'The "add" command requires at least 1 '
                               'argument.')

        with self.assertRaises(Exit) as cm:
            main_core(['add', '1', '2', '3'])
        self.assertExit(cm, 1, 'The "add" command requires at most 2 '
                               'arguments.')

    def test_run_unittest(self):

        original_sys_exit = sys.exit
        try:
            def my_exit(ret):
                wl('Exit: %s', ret)
            sys.exit = my_exit

            main_core(['test', 'test_w'])
            self.assertRegex(self.output,
                '.\n' +
                '-' * 70 + '\n'
                'Ran 1 test in .*s\n'
                '\n'
                'OK\n'
                'Exit: 0\n')
        finally:
            sys.exit = original_sys_exit
            self.output = ''

    def test_coverage(self):
        main_core(['test-coverage'])
        self.assertCalls([['coverage', 'run', sys.argv[0], 'test'],
                          ['coverage', 'report'],
                          ['coverage', 'html']])
        self.assertOutput('Coverage report ready '
                          '(open htmlcov/index.html).')

        global call
        original_call = call
        try:
            def my_call(cmd):
                raise Exit(1, 'msg')
            call = my_call
            with self.assertRaises(Exit) as cm:
                main_core(['test-coverage'])
            self.assertExit(cm, 1, '''msg
Probably this means that "coverage" is not installed. You can install coverage
with "pip install coverage" (you may also need "sudo").''')
        finally:
            call = original_call

    def test_main_core(self):

        with self.assertRaises(Exit) as cm:
            main_core(['nosuchcommand'])
        self.assertExit(cm, 1, 'Unrecognized command: nosuchcommand.')

    def test_main(self):

        global main_core

        original_sys_exit = sys.exit
        original_main_core = main_core
        try:

            def my_exit(ret):
                wl('Exit: %s', ret)
            sys.exit = my_exit

            def my_main_core(*args):
                raise Exit(0, 'msg')
            main_core = my_main_core
            main()
            self.assertOutput('msg')

            def my_main_core(*args):
                raise Exit(1, 'msg')
            main_core = my_main_core
            main()
            self.assertOutput('Error: msg',
                              'Exit: 1')

        finally:
            sys.exit = original_sys_exit
            main_core = original_main_core

if __name__ == '__main__':
    main()
